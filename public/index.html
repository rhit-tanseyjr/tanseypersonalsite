<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>John Tansey - Computer Engineering Portfolio</title>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet" />
    <style>
        :root {
            --dark-bg: #1a1a1a;
            --card-bg: #2d2d2d;
            --accent-blue: #00e1ff;
            --accent-yellow: #fdf800;
            /* CHANGE THIS TO MODIFY YELLOW COLOR */
            --text-primary: #f0f0f0;
            --text-secondary: #cccccc;
        }

        * {
            box-sizing: border-box;
        }

        /* body {
            margin: 0;
            background-color: var(--dark-bg);
            color: var(--text-primary);
            font-family: 'Share Tech Mono', monospace;
            line-height: 1.5;
            letter-spacing: 0.7px;
            min-height: 100vh;
            transition: opacity 0.8s ease;
        }*/
        body {
            background:
                linear-gradient(rgba(26, 26, 26, 0.85), rgba(26, 26, 26, 0.85)),
                url('https://i.redd.it/mdvmefeejg331.jpg') no-repeat center center fixed;
            background-size: cover;
            margin: 0;
            color: var(--text-primary);
            font-family: 'Share Tech Mono', monospace;
            line-height: 1.5;
            letter-spacing: 0.7px;
            min-height: 100vh;
            transition: opacity 0.8s ease;
        }


        body.loaded {
            opacity: 1;
        }

        /* LOADING ANIMATION */
        /*
  #loader {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--dark-bg);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    transition: opacity 0.8s ease-out;
  }
  
  .loader-content {
    text-align: center;
    width: 300px;
  }
  
  .terminal-text {
    color: var(--accent-yellow);
    font-family: 'Share Tech Mono', monospace;
    font-size: 1.2rem;
    margin-bottom: 2rem;
    overflow: hidden;
    white-space: nowrap;
    border-right: 0.15em solid var(--accent-yellow);
    animation: typing 3.5s steps(40, end), blink-caret 0.75s step-end infinite;
  }
  
  @keyframes typing {
    from { width: 0 }
    to { width: 100% }
  }
  
  @keyframes blink-caret {
    from, to { border-color: transparent }
    50% { border-color: var(--accent-yellow) }
  }
  
  .progress-text {
    color: var(--accent-yellow);
    font-family: 'Share Tech Mono', monospace;
    margin-top: 2rem;
    font-size: 0.9rem;
    text-align: center;
  }
  
  .progress-bar {
    width: 100%;
    height: 4px;
    background: #444;
    margin: 1rem auto;
    overflow: hidden;
    border-radius: 2px;
  }
  
  .progress {
    height: 100%;
    width: 0;
    background: var(--accent-yellow);
    transition: width 0.3s ease;
  }
  
  body.loaded #loader {
    opacity: 0;
    pointer-events: none;
  }
  */

        header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: var(--card-bg);
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 9999;
            border-bottom: 1px solid var(--accent-yellow);
        }

        .header-left {
            display: flex;
            flex-direction: column;
        }

        .header-left h1 {
            margin: 0;
            font-size: 1.5rem;
        }

        .header-right a {
            margin-left: 1rem;
            transition: color 0.3s ease;
        }

        .header-right a:hover {
            color: var(--accent-yellow);
        }

        .header-right svg {
            width: 24px;
            height: 24px;
            vertical-align: middle;
        }

        a[href^="mailto:"] {
            color: var(--text-primary);
            text-decoration: none;
        }

        a[href^="mailto:"]:hover {
            text-decoration: underline;
        }

        .header-right svg {
            fill: #ffffff;
        }

        main {
            margin-top: 90px;
            padding: 1rem;
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 2.5rem;
            max-width: 1400px;
            margin-left: auto;
            margin-right: auto;
            width: 100%;
        }

        @media (max-width: 900px) {
            main {
                display: block;
                padding: 1rem;
            }
        }


        section {
            background-color: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            border: 1px solid #444;
        }

        h1,
        h2,
        h3 {
            margin-top: 0;
            color: var(--accent-yellow);
            /* Yellow acc */
        }

        section h2::after {
            content: '';
            display: block;
            width: 100%;
            height: 2px;
            background: var(--accent-yellow);
            margin-top: 0.5rem;
        }

        /* SKILLS LIST */
        .skills-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 0.7rem 1.5rem;
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .code-section {
            margin-top: 1.5rem;
            background: #3d3d3d;
            border-radius: 6px;
            padding: 0.5rem;
            border-left: 3px solid var(--accent-yellow);
            border: 1px solid #555;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .code-header h3 {
            margin: 0;
            color: var(--accent-yellow);
            font-size: 1.1rem;
        }

        .code-content {
            margin: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .code-section.active .code-content {
            max-height: 500px;
            margin-top: 0.5rem;
        }

        .code-content pre {
            background: #2a2a2a;
            padding: 1rem;
            border-radius: 4px;
            margin: 0;
            overflow-x: auto;
        }

        .code-content code {
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        /* 
        .skills-list li {
            background: #3d3d3d;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.9rem;
            text-align: center;
            border: 1px solid #555;
        } */

        .skills-list li {
            background: #3d3d3d;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.9rem;
            text-align: center;
            border: 1px solid #555;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* PROJECT/JOB STYLES */
        .job,
        .project {
            margin-bottom: 0.5rem;
            background: #3d3d3d;
            border-radius: 6px;
            padding: 0.5rem;
            border-left: 3px solid var(--accent-yellow);
            /* Yellow accent */
            border: 1px solid #555;
        }

        .project-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .job-title,
        .project-title {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--accent-yellow);
            /* Yellow titles */
            margin-bottom: 0.3rem;
        }

        .company {
            font-style: italic;
            color: var(--text-secondary);
            font-size: 0.95rem;
            margin-bottom: 0.4rem;
        }

        .date {
            color: #999;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .processor-visualization {
            margin-top: 1rem;
        }

        .diagram-img,
        .chart-img {
            width: 100%;
            border: 1px solid #444;
            border-radius: 4px;
            margin: 0.5rem 0;
        }

        .diagram-caption {
            text-align: center;
            font-style: italic;
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
            font-size: 0.9rem;
        }

        .feature-highlights,
        .technical-details,
        .achievements {
            margin: 1.5rem 0;
        }

        .feature-highlights h3,
        .technical-details h3,
        .achievements h3 {
            color: var(--accent-yellow);
            border-bottom: 1px solid var(--accent-yellow);
            padding-bottom: 0.3rem;
            margin-bottom: 1rem;
        }

        .feature-highlights ul,
        .achievements ul {
            padding-left: 1.5rem;
        }

        .feature-highlights li,
        .achievements li {
            margin-bottom: 0.5rem;
        }

        .detail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .detail-item {
            background: #3d3d3d;
            padding: 1rem;
            border-radius: 6px;
            border-left: 3px solid var(--accent-yellow);
        }

        .detail-item h4 {
            margin-top: 0;
            color: var(--accent-yellow);
        }

        .project-links {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .project-links a {
            background: var(--accent-yellow);
            color: #000;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            text-decoration: none;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .project-links a:hover {
            background: #ffff66;
        }

        .description {
            margin: 0;
            white-space: pre-line;
            font-size: 0.95rem;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                margin-top 0.3s ease;
            will-change: max-height;
        }

        .project.active .description {
            max-height: 500px;
            margin-top: 0.5rem;
            transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1),
                margin-top 0.3s ease;
        }

        .toggle-icon {
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .toggle-icon {
            transition: transform 0.3s ease;
            color: var(--accent-yellow);
        }

        .project.active .toggle-icon {
            transform: rotate(180deg);
        }

        .job .description {
            margin: 0;
            white-space: pre-line;
            font-size: 0.95rem;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: max-height;
        }

        .job.active .description {
            max-height: 500px;
            margin-top: 0.5rem;
        }

        .job-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .job .toggle-icon {
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            color: var(--accent-yellow);
        }

        .job.active .toggle-icon {
            transform: rotate(180deg);
        }

        /* FOOTER */
        footer {
            grid-column: 1 / -1;
            text-align: center;
            margin-top: 3rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
            padding: 1rem;
            border-top: 1px solid rgba(253, 248, 0, 0.3);
            /* Yellow accent */
        }

        /* RESPONSIVE ADJUSTMENTS */
        @media (max-width: 600px) {
            .skills-list {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            }
        }
    </style>
</head>

<body>

    <!-- Loading Animation -->
    <!--
<div id="loader">
  <div class="loader-content">
    <div class="terminal-text">Initializing Portfolio...</div>
    <div class="progress-text">Indexing: <span id="progress-percent">0</span>%</div>
    <div class="progress-bar">
      <div class="progress" id="progress-bar"></div>
    </div>
  </div>
</div>
-->

    <header>
        <div class="header-left" role="banner">
            <h1>John Tansey</h1>
        </div>
        <div class="header-right">
            <a href="https://linkedin.com/in/john-r-tansey" target="_blank" aria-label="LinkedIn Profile"
                rel="noopener noreferrer">
                <svg role="img" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M4.98 3.5C4.98 4.88 3.87 6 2.5 6S0 4.88 0 3.5 1.12 1 2.5 1 4.98 2.12 4.98 3.5zM.08 8h5.15v12H.08V8zm7.41 0h4.94v1.7h.07c.69-1.3 2.38-2.67 4.89-2.67 5.23 0 6.2 3.43 6.2 7.9V20H17v-6.12c0-1.46-.03-3.33-2.03-3.33-2.03 0-2.34 1.59-2.34 3.23V20H7.49V8z" />
                </svg>
            </a>
            <a href="https://github.com/rhit-tanseyjr" target="_blank" aria-label="GitHub Profile"
                rel="noopener noreferrer">
                <svg role="img" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                    <path
                        d="M12 0C5.37 0 0 5.37 0 12c0 5.3 3.44 9.79 8.21 11.38.6.11.82-.26.82-.58v-2.2c-3.34.73-4.04-1.61-4.04-1.61-.54-1.37-1.33-1.74-1.33-1.74-1.09-.75.08-.74.08-.74 1.2.08 1.83 1.23 1.83 1.23 1.07 1.83 2.81 1.3 3.5.99.11-.78.42-1.3.76-1.6-2.67-.3-5.47-1.34-5.47-5.96 0-1.32.47-2.39 1.23-3.23-.12-.3-.54-1.52.11-3.16 0 0 1-.32 3.3 1.23a11.45 11.45 0 0 1 6 0c2.3-1.55 3.3-1.23 3.3-1.23.65 1.64.23 2.86.12 3.16.77.84 1.23 1.91 1.23 3.23 0 4.63-2.8 5.66-5.48 5.96.43.37.81 1.1.81 2.22v3.29c0 .32.21.7.83.58A12.02 12.02 0 0 0 24 12c0-6.63-5.37-12-12-12z" />
                </svg>
            </a>
        </div>
    </header>

    <main>
        <div class="left-column">
            <section id="about-me" aria-label="About Me">
                <h2>About Me</h2>
                <p>Third Year Computer Engineering student at Rose-Hulman Institute of Technology seeking an internship
                    for Summer 2026.</p>
            </section>

            <section id="contact-me" aria-label="Contact Me">
                <h2>Contact Me</h2>
                <p>Email: <a href="mailto:tanseyjr@rose-hulman.edu">tanseyjr@rose-hulman.edu</a></p>
                <p>Phone: (608) 695-4271</p>
            </section>

            <section id="skills" aria-label="Skills">
                <h2>Skills</h2>
                <ul class="skills-list" aria-label="Technical skills list">
                    <li>Git, CVS</li>
                    <li>Jira, Monday</li>
                    <li>Linux (RHEL, Ubuntu)</li>
                    <li>TempleOS</li>
                    <li>C++</li>
                    <li>C</li>
                    <li>C#</li>
                    <li>Verilog</li>
                    <li>Assembly (RISC-V, ARM Thumb II)</li>
                    <li>Bash</li>
                    <li>Java</li>
                    <li>Python</li>
                    <li>SQL</li>
                    <li>MATLAB</li>
                    <li>HolyC</li>
                    <li>CUDA</li>
                    <li>JSON</li>
                    <li>Markdown</li>
                    <li>Eclipse, ModelSim, VS Code, Vim</li>
                    <li>Simulink</li>
                    <li>Embedded Systems</li>
                    <li>Project Management (SDLC)</li>
                    <li>Signal Processing</li>
                    <li>PCB Design, Circuit Simulation</li>
                    <li>Semiconductor Simulation Software</li>
                    <li>Computer Architecture</li>


                </ul>
            </section>
        </div>

        <div class="right-column">
            <section id="project-experience" aria-label="Project Experience">
                <h2>Project Experience</h2>

                <div class="project">
                    <div class="project-header">
                        <div>
                            <p class="project-title">Radiation Hardened Semiconductor Simulations</p>
                            <p class="date">Jun 2025 – Aug 2025</p>
                        </div>
                        <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <p class="description">
                        • Simulated radiation-hardened semiconductors using CUDA and PETSC, used parallelization to
                        reduce processing time
                        • Developed a new testing framework and performed GPU hardware analysis to recommend cost
                        effective hardware solutions
                        • <a href="https://www.jrcisi.com/radiation-analysis-and-design-software-tools" target="_blank"
                            rel="noopener noreferrer" class="more-info-link">View JRC Integrated Systems
                            Information↗</a>

                    </p>
                </div>

                <div class="project">
                    <div class="project-header">
                        <div>
                            <p class="project-title">Battery Management Systems</p>
                            <p class="date">Aug 2024 – Jan 2025</p>
                        </div>
                        <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <p class="description">

                        • Worked under the Battery Management System team for the Rose-Hulman Battery Workforce
                        Challenge team.
                        • Worked with Simulink, coded controls and response for electric vehicle pre-charging and
                        crash detection
                        • Utilized serial communication with microcontrollers
                        • <a href="https://avtcseries.org/about-the-battery-workforce-challenge/" target="_blank"
                            rel="noopener noreferrer" class="more-info-link">More Info</a>
                    </p>
                </div>

                <!-- <div class="project">
                    <div class="project-header">
                        <div>
                            <p class="project-title">Pipelined RISC-V Processor</p>
                            <p class="date">Dec 2024 – Feb 2025</p>
                        </div>
                        <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <p class="description">
                        • Implemented a RISC-V processor in Verilog, evolving from single-cycle to pipelined
                        architecture
                        • Added branch/jump handling with decode-stage detection and pipeline flushing
                        • Designed and integrated stall detection and data forwarding units to resolve hazards
                        • Verified correctness with custom testbenches and benchmarked
                        <code>gcd</code>/<code>relPrime</code> programs
                        • Created and integrated a custom <code>gcd</code> instruction, eliminating branching and loops
                        by computing directly in hardware
                        • Reduced relPrime runtime from 172 → 58 cycles (n=6), 51,151 → 124 cycles (n=5040), and 366,757
                        → 200 cycles (n=30030)
                        • Achieved extreme scalability: estimated reduction from ~4.98×10<sup>12</sup> → 317 cycles for
                        n=223,092,870 (most difficult relative prime number testable on the register size)
                        • Demonstrated speedups exceeding <strong>10<sup>10</sup>×</strong> while improving readability,
                        predictability, and hardware efficiency
                        • <a href="https://github.com/rhit-csse232/rhit-csse232-2425b-pipe-tulip-2425b-pipe-02"
                            target="_blank" rel="noopener noreferrer" class="more-info-link">View GitHub Repository↗</a>
                    </p>
                </div> -->
                <div class="project">
                    <div class="project-header">
                        <div>
                            <p class="project-title">Pipelined RISC-V Processor</p>
                            <p class="date">Dec 2024 – Feb 2025</p>
                        </div>
                        <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <div class="description">
                        <div class="processor-visualization">
                            <div class="processor-diagram">
                                <h3>Pipeline Architecture:</h3>
                                <img src="images/png2.svg" alt="RISC-V Processor Pipeline Diagram" class="diagram-img">
                                <p class="diagram-caption">5-stage pipelined RISC-V architecture with hazard detection
                                </p>
                            </div>


                            <div class="feature-highlights">
                                <h3>Key Features:</h3>
                                <ul>
                                    <p><strong>5-Stage Pipeline:</strong> IF, ID, EX, MEM, WB with full forwarding </p>
                                    <p><strong>Hazard Handling:</strong> Advanced data forwarding and stall detection
                                    </p>
                                    <p><strong>Extended ISA:</strong> Custom GCD instruction for hardware acceleration
                                    </p>
                                    <p><strong>Memory-Mapped I/O:</strong> Integrated input/output system </p>
                                    <p><strong>Branch Prediction:</strong> Early branch resolution in decode stage </p>
                                </ul>
                            </div>
                            <div class="performance-comparison">
                                <h3>Waveform Analysis:</h3>
                                <img src="https://via.placeholder.com/800x300/2d2d2d/00e1ff?text=Waveform+Analysis+Showing+Pipeline+Execution"
                                    alt="Waveform analysis of pipeline execution" class="chart-img">
                                <p class="diagram-caption">GTKWave simulation showing pipeline execution and hazard
                                    handling</p>
                            </div>
                            <div class="technical-details">
                                <h3>Technical Implementation:</h3>
                                <div class="detail-grid">
                                    <div class="detail-item">
                                        <h4>Pipeline Control</h4> Implemented full forwarding unit with EX/MEM and
                                        MEM/WB stage forwarding
                                    </div>
                                    <div class="detail-item">
                                        <h4>Hazard Detection</h4> Designed stall logic for load-use hazards and control
                                        hazards
                                    </div>
                                    <div class="detail-item">
                                        <h4>Custom ALU</h4> Extended ALU with GCD and MUL operations beyond standard
                                        RISC-V
                                    </div>
                                    <div class="detail-item">
                                        <h4>Verification</h4> Comprehensive testbenches with custom vUnit testing
                                        framework
                                    </div>
                                </div>
                            </div>
                            <div class="achievements">
                                <h3>Achievements:</h3>
                                <ul>
                                    <li>Implemented a RISC-V processor in Verilog, evolving from single-cycle to
                                        pipelined architecture</li>
                                    <li>Added branch/jump handling with decode-stage detection and pipeline flushing
                                    </li>
                                    <li>Designed and integrated stall detection and data forwarding units to resolve
                                        hazards</li>
                                    <li>Verified correctness with custom testbenches and benchmarked
                                        <code>gcd</code>/<code>relPrime</code> programs
                                    </li>
                                    <li>Created and integrated a custom <code>gcd</code> instruction, eliminating
                                        branching and loops by computing directly in hardware</li>
                                    <li>Reduced relPrime runtime from 172 → 58 cycles (n=6), 51,151 → 124 cycles
                                        (n=5040), and 366,757 → 200 cycles (n=30030)</li>
                                    <li>Achieved extreme scalability: estimated reduction from ~3.98×10<sup>12</sup> →
                                        317 cycles for n=223,092,870</li>
                                    <li>Demonstrated speedups exceeding <strong>10<sup>10</sup>×</strong> while
                                        improving readability, predictability, and hardware efficiency</li>
                                </ul>
                            </div>
                            - <a href="https://github.com/rhit-csse232/rhit-csse232-2425b-pipe-tulip-2425b-pipe-02"
                                target="_blank" rel="noopener noreferrer" class="more-info-link">View GitHub
                                Repository↗</a>

                        </div>
                    </div>
                </div>


                <div class="project">
                    <div class="project-header">
                        <div>
                            <p class="project-title">Infrared-Seeking Missile Control System (Project Leader)</p>
                            <p class="date">Jan 2025 – Feb 2025</p>
                        </div>
                        <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <p class="description">
                        • Developed real-time infrared tracking missile prototype using MSP432 microcontroller with
                        autonomous target acquisition
                        • Designed servo-controlled guidance system with 4 independent fins achieving sub 100ms response
                        time and 5% angle accuracy
                        • Implemented state machine logic (Base→Armed→Fire) with audio/visual feedback and
                        proximity-based detonation
                        • Optimized IR signal processing with rotating optical assembly (stepper motor + photodiode +
                        concave mirror)
                        • Achieved warhead trigger latency of 130μs and ignition response within 1ms through
                        hardware-software co-design
                        • Integrated serial communication interface and backup button redundancy for robust control
                        • <a href="https://github.com/rhit-tanseyjr/ECE-230-Final-Project" target="_blank"
                            rel="noopener noreferrer" class="more-info-link">View GitHub Repository↗</a>
                    </p>
                </div>
                <div class="project">
                    <div class="project-header">
                        <div>
                            <p class="project-title">RISC-V 32-bit Assembler</p>
                            <p class="date">Aug 2024 – Nov 2024</p>
                        </div>
                        <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <div class="description">
                        <div class="assembler-details">
                            <div class="feature-highlights">
                                <h3>Core Features:</h3>
                                <ul>
                                    <li><strong>Complete RISC-V Support:</strong> Full implementation of R, I, S, SB, U,
                                        and UJ instruction types</li>
                                    <li><strong>Label Resolution:</strong> Automatic address calculation and branch/jump
                                        target resolution</li>
                                    <li><strong>Pseudoinstruction Framework:</strong> Extensible system for custom
                                        instruction macros</li>
                                    <li><strong>Multi-format Output:</strong> Binary, hexadecimal, and annotated
                                        assembly output modes</li>
                                    <li><strong>Comprehensive Error Handling:</strong> Detailed exception system for
                                        debugging invalid assembly</li>
                                </ul>
                            </div>

                            <div class="technical-details">
                                <h3>Technical Implementation:</h3>
                                <div class="detail-grid">
                                    <div class="detail-item">
                                        <h4>Multi-Pass Architecture</h4>
                                        Four-pass design: comment removal, pseudoinstruction expansion, label parsing,
                                        and machine code generation
                                    </div>
                                    <div class="detail-item">
                                        <h4>Instruction Encoding</h4>
                                        Precise bit-field manipulation for all RISC-V instruction formats with two's
                                        complement immediate handling
                                    </div>
                                    <div class="detail-item">
                                        <h4>Address Resolution</h4>
                                        PC-relative addressing with automatic offset calculation for branches and jumps
                                    </div>
                                    <div class="detail-item">
                                        <h4>Register Mapping</h4>
                                        Complete register alias support (x0-x31, ra, sp, t0-t6, s0-s11, a0-a7, etc.)
                                    </div>
                                </div>
                            </div>

                            <div class="achievements">
                                <h3>Key Achievements:</h3>
                                <ul>
                                    <li>Developed complete 32-bit RISC-V assembler supporting all major instruction
                                        types</li>
                                    <li>Implemented sophisticated label resolution system with forward reference support
                                    </li>
                                    <li>Created extensible pseudoinstruction framework allowing custom macro definitions
                                    </li>
                                    <li>Built comprehensive error handling with specific exception types (BadImmediate,
                                        BadRegister, BadLabel, etc.)</li>
                                    <li>Designed multi-format output system with debugging annotations and address
                                        mapping</li>
                                    <li>Achieved full compatibility with standard RISC-V assembly syntax including
                                        base-offset addressing</li>
                                    <li>Implemented robust two's complement arithmetic for immediate value encoding</li>
                                    <li>Created modular architecture enabling easy extension for additional instruction
                                        sets</li>
                                </ul>
                            </div>
                            <div class="code-section">
                                <div class="code-header">
                                    <h3>Source Code</h3>
                                    <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                                        stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                        stroke-linejoin="round">
                                        <polyline points="6 9 12 15 18 9"></polyline>
                                    </svg>
                                </div>
                                <div class="code-content">
                                    <pre><code>
"""""
 Assembler for 32-bit RISC-V
 made for CSSE232
 John Tansey, Rishi Ramesh

"""
import string
import re
# python3 -m pdoc assembler.py -o=docs 
import sys, argparse
from enum import Enum
import pseudoinstruction_handler as ph

def main(args):
    assemble_asm(args.asm.readlines(), args)


def assemble_asm(asm_lines, args = None):
    """Takes a list of strings of assembly code. The strings san contain instructions, 
    labels, blank lines, and comments indicated with `;` (on their own line or following instructions).
    Removes comments and blanks and assembles the entire code, returning a list 
    containing binary strings of machine code."""

    #clean up the code removing comments and blanks
    print("Cleaning comments...")
    asm_list = comments_pass(asm_lines)

    #process the pseudoinstruction defninition
    print("Processing pseudoinstructions...")
    pseudos = ph.get_pseudoinstruction_defs()
    core_asm = pseudoinstruction_pass(asm_list, pseudos)

    #extract the labels
    print("Creating labels...")
    clean_code, labels = parse_labels(core_asm)

    #assemble each line
    print("Translating to machine code...")
    machine_code = machine_pass(clean_code, labels)
    
    #output the code
    #set out=None to print to console
    print("Outputting...")
    mode = None
    out = None
    if(args):
        out = args.out
        if(args.verbose):
            mode = None
        else:
            mode = args.mode
    output(machine_code, clean_code, labels, mode = mode, out = out)

    print("Done.")
    return machine_code

##############
#
# Helpers which define the major passes of the assembler 
#
##############
def comments_pass(asm_lines):
    """Takes in a list representing the contents of an asm file.
        Returns a new list with comments and blank lines removed from the list."""
    asm_list = []
    for line in asm_lines:
        line = remove_comments(line.lstrip())
        if(line == None):
            continue
        asm_list.append(line)
    return asm_list

def pseudoinstruction_pass(asm_lines, pseudos_dictionary):
    """Takes in a list of assembly instructions (with no comments, labels are okay) 
        and returns a new list where any pseudoinstructions are replaced with their 
        equivalent core instructions."""
    
    newLines = []


    for i in range(len(asm_lines)):
        line = asm_lines[i]  # Get the current line
        label, instr = split_out_label(line)
        command = instr.split()[0]  # Extract the command (e.g., "diffsums")

        if(has_label(line)):
            command = instr.split()[0]


        if command in pseudos_dictionary:
            # Expand pseudo-instruction
           
            expanded_lines = pseudos_dictionary[command](instr, i)
            # Append expanded lines to newLines
            newLines.extend(expanded_lines)
        else:
            newLines.append(line)

    return newLines

def machine_pass(asm_lines, labels_dictionary):
    """Taken in a list of assembly lines with no comments or pseudoinstructions. 
        Returns a list containing the binary machine translation of each line."""
    machine_code = []
    for i, line in enumerate(asm_lines):
        result = Assemble(line, i, labels_dictionary)
        machine_code.append(result)

    return machine_code

##############
#
# Actual Assembler Methods
#
##############
def Assemble(inst, line_num=0, labels=None):
    """Takes an instruction as a string, splits it into parts, and then calls the correct helper
        to assemble it, returning the result.
        The optional parameter `labels` should be a Dictionary mapping Label strings 
        to addresses.
        
        This function and the helpers should raise exceptions when invalid instructions are
        encountered. See the exceptions types defined below in this file, they are all named 
        `BadX` where X is a particular kind of error (e.g. `BadImmediate`). 

        Some test cases rely on these errors being raised at appropriate times. 

        This function (and each of the helpers) should return a binary string with bits in groups of 4
        separated by a space character:

        `0000 1111 0000 1111 0000 1111 0000 1111`

        The spacing is intended to make debugging easier.
        """

    split_inst = inst.strip().replace(",", " ").split()
    cmd = split_inst[0]
    args = split_inst[1:]


    type = inst_to_types.get(cmd)

    # index_to_address(4)
    result = ""
    match type:
        case Types.R:
            result = Assemble_R_Type(cmd, args, line_num)
        case Types.I:
            if(cmd == 'lw' or cmd == "jalr"):
                result = Assemble_I_Type_base_offset(cmd, args, line_num)
            else:
                result = Assemble_I_Type(cmd, args, line_num)
        case Types.S:
            result = Assemble_S_Type(cmd,args,line_num) 
        case Types.U:
            result = Assemble_U_Type(cmd, args, line_num)  
        case Types.UJ:
            result = Assemble_UJ_Type(cmd, args, line_num,labels) 
        case Types.SB:
            result = Assemble_SB_Type(cmd, args, line_num,labels )      
    return result

def Assemble_R_Type(cmd, operands, line_num):
    """Takes an R Type instruction name and its operands (as a list) and 
        returns the appropriate binary string. A basic call would look like:
        
        `Assemble_R_Type("add", ["t0", "t1", "x2"], 0)`
        
        You may want to consider implementing `verify_field_sizes` that will
        take a list of binary values and make sure each one is the right size
        for the field (funct7, etc). Using it here and in all future
        instruction types may help in debugging.

        Raises BadInstruction exception when the cmd is not a valid R-type.

        Raises BadOperands exception when the wrong number of operands is
        provided or if base-offset notation is used.

        Raises BadRegister exception if one of the operands provided is not a
        valid register name (e.g., it is an immediate or label)
    """

    if(len(operands) != 3):
        raise BadOperands("Incorrect number of operands found in R Type on line %s with args:\n\t%s %s\n" % (line_num, cmd, operands))

    field_data = inst_to_fields[cmd]

    rd  = get_register_bin(operands[0])
    rs1 = get_register_bin(operands[1])
    rs2 = get_register_bin(operands[2])

    if(not is_register_name(operands[2])):
        raise BadRegister()
    
    if(not is_register_name(operands[1])):
        raise BadRegister()
    
    if(not is_register_name(operands[0])):
        raise BadRegister()

    inst_field_list = [field_data.func7,
                       rs2,
                       rs1,
                       field_data.func3,
                       rd, 
                       field_data.opcode]

    return join_inst_fields_bin(inst_field_list)

def Assemble_I_Type(cmd, operands, line_num):
    """Takes an I Type instruction name and its operands (as a list) and 
        returns the appropriate binary string.

        Raises BadInstruction exception when the cmd is not a valid I-type.

        Raises BadOperands exception when the wrong number of operands is
        provided

        Raises BadRegister exception if one of the operands in a register
        position (rd or rs1) is not a valid register name

        Raises BadImmediate exception when the value provided does not fit in
        the instruction's immediate space.
    """



    if(len(operands) != 3):
        raise BadOperands("Incorrect number of operands found in R Type on line %s with args:\n\t%s %s\n" % (line_num, cmd, operands))
    
    if(not is_core_inst(cmd)):
        raise BadInstruction()
    
    field_data = inst_to_fields[cmd]

    rd  = get_register_bin(operands[0])
    rs1 = get_register_bin(operands[1])
    imm = dec_to_bin(operands[2], size = 12)

    

    inst_field_list = [imm,
                       rs1,
                       field_data.func3,
                       rd, 
                       field_data.opcode]

    return join_inst_fields_bin(inst_field_list)
    


def Assemble_I_Type_shift(cmd, operands, line_num):
    """Takes an I Type instruction name and its operands and returns 
        the appropriate binary string.

        Replaces `imm[11:5]` with the "func7" bits for the instructions defined 
        by the green sheet.
        
        Note: recall that the rightmost bit in a RISC-V immediate is index 0,
        but python indexes strings left to right, so in a 12 bit immediate
        the rightmost bit in RISC-V is index 0 but in python that same bit
        is index 11.

        Raises BadInstruction exception when the cmd is not a valid I-type
        shift.

        Raises BadOperands exception when the wrong number of operands is
        provided

        Raises BadRegister exception if one of the operands in a register
        position (rd or rs1) is not a valid register name

        Raises BadImmediate exception when the value provided is negative or
        greater than 31.
        """


    if(int(operands[2]) < 0 or int(operands[2]) > 13):
        raise BadImmediate("Immediate value outside of bounds")

    if(len(operands) != 3):
        raise BadOperands("Incorrect number of operands found in R Type on line %s with args:\n\t%s %s\n" % (line_num, cmd, operands))
    
   
    if(not is_core_inst(cmd)):
        raise BadInstruction()
    
    
    

    field_data = inst_to_fields[cmd]

    rd  = get_register_bin(operands[0])
    rs1 = get_register_bin(operands[1])
    imm = dec_to_bin(operands[2], size = 12)

    if(cmd == "srai"):
        imm = '010000' + imm[6:13]

    

    inst_field_list = [imm,
                       rs1,
                       field_data.func3,
                       rd, 
                       field_data.opcode]

    return join_inst_fields_bin(inst_field_list)

def Assemble_I_Type_base_offset(cmd, operands, line_num):
    """Takes the operands for a lw or jalr instruction and returns the 
        appropriate binary string. You may want to implement and use
        the `parse_base_offset` helper method before writing this code.

        Note that the following are valid syntax for base-offset instructions (like jalr):
            jalr x0, 4 (ra)  // <- space betwen 4 and (ra)
            jalr x0, ra, 4   // <- standard I-type format
            jalr x0, 4(ra)   // <- no space between offset and base
        
        Raises BadInstruction exception when the cmd is not a valid I-type
        base-offset instruction.

        Raises BadOperands exception when the wrong number of operands is
        provided.

        Raises BadRegister exception if one of the operands in a register
        position is not a valid register name.

        Raises BadImmediate exception when the value provided will not fit in
        the immediate space for the instruction or if there is a register
        specifier in the immediate operand location.
 """



    if(not is_core_inst(cmd)):
        raise BadInstruction()
    
    if(len(operands) != 2 and cmd != "jalr"):
        raise BadOperands()
    if (cmd == 'jalr') and len(operands) == 3:
        if operands[2].isdecimal() and not operands[1].isdecimal():
            operands[1], operands[2] = operands[2], operands[1]

            if not (operands[2].startswith('(') and operands[2].endswith(')')):
                operands[2] = f"({operands[2]})"



    if(cmd == "jalr" and len(operands) == 3):
        rs1 = parse_base_offset(operands[1] + operands[2])[1]
 
    else:
        rs1 = parse_base_offset(operands[1])[1]

    rd = get_register_bin(operands[0])

    if(operands[1][0] == '-'):
        imm = dec_to_bin(operands[1][0:2], size = 12)

    else:
        imm = dec_to_bin(operands[1][0], size = 12)


 
    
    field_data = inst_to_fields[cmd]

    inst_field_list = [imm,
                       rs1,
                       field_data.func3,
                       rd, 
                       field_data.opcode]

    return join_inst_fields_bin(inst_field_list)
    

def Assemble_I_Type_from_fields(imm, rs1, func3, rd, opcode, line_num):
    """Helper function for I Types to be called after the immediate has 
        been processed by the main I Type functions."""

    return "0000 0000 0000 0000 0000 0000 0000 0000"

def Assemble_S_Type(cmd, operands, line_num):
    """Takes the operands for an S Type instruction and returns the 
        appropriate binary string.

        Raises BadInstruction exception when the cmd is not a valid S-type
        instruction.

        Raises BadOperands exception when the wrong number of operands is
        provided.

        Raises BadRegister exception if one of the operands in a register
        position is not a valid register name.

        Raises BadImmediate exception when the value provided will not fit in
        the immediate space for the instruction or if there is a register
        specifier in the immediate operand location.
    """


    if(not is_core_inst(cmd)):
        raise BadInstruction()
    
    if(len(operands) != 2):
        raise BadOperands()
      
 
    rs2 = get_register_bin(operands[0])

    if(operands[1][0] == '-'):
        rs1 = get_register_bin(operands[1].split('(')[1].rstrip(')'))
        if(rs1.isdigit == False):
            raise BadRegister()
    else:
        rs1 = get_register_bin(operands[1].split('(')[1].rstrip(')'))
        if(rs1.isdigit == False):
            raise BadRegister()

    if(operands[1][0] == '-'):
        imm = dec_to_bin(operands[1].split('(')[0], size = 12)
        # if(operands[1][0:2] < -(2^11)):
        #     raise BadImmediate()
    else:
        imm = dec_to_bin(operands[1].split('(')[0], size = 12)
        # if(operands[1][0] > 2^11-1):
        #     raise BadImmediate()

   # if(int(imm) > 2^11-1 or int(imm) < -(2^11)):
    #    raise BadImmediate()

    firstBits = imm[:7]
    secondBits = imm[7:]
    
    field_data = inst_to_fields[cmd]

    inst_field_list = [firstBits,
                       rs2,
                       rs1,
                       field_data.func3,
                       secondBits, 
                       field_data.opcode]

    return join_inst_fields_bin(inst_field_list)

def format_address(address):
    register = address[0]
    offset = address[1:]
    return f"{offset}({register})"

def Assemble_SB_Type(cmd, operands, line_num, labels=None):
    """Takes an SB Type instruction name and its operands (as a list) 
        and returns the appropriate binary string. 
        
        This method assumes that if a number is passed in as the 
        third operand (`operands[2]`) it is the PC offset, not the immediate. 
        Therefore the offset will be right-shifted before the immediate is generated.
        
        If a non-integer is passed in instead then this method
        expects that to be a label who's address is specified in the `labels`
        dictionary. 
        
        In both cases the `line_num` is used to calculate the immediate from
        the offset. You should assume that a `line_num` equal to 0 indicates
        an instruction at the beginning of the text segment of memory. 
        
        You should consider writing and using the `index_to_address` and
        `label_to_offset` methods for use in this instruction type (and others).

        Raises BadInstruction exception when the cmd is not a valid SB-type.

        Raises BadOperands exception when the wrong number of operands is
        provided.

        Raises BadRegister exception if one of the operands in a register
        position is not a valid register name.

        Raises BadImmediate exception when the value provided will not fit in
        the immediate space for the instruction or if there is a register
        specifier in the immediate operand location.
        """


    if(not is_core_inst(cmd)):
        raise BadInstruction()
    
    if(len(operands) == 3):
        offset = operands[2]
        if(offset.isdecimal() or offset[0] == '-'): 
            imm = (dec_to_bin(int(offset) >> 1))
        elif(is_register_name(offset)):
            raise BadImmediate()
        else:
            imm = dec_to_bin(int(label_to_offset(labels, offset, line_num)) >> 1)
    elif(len(operands) == 2):
        imm = 0
    else:
        raise BadOperands()
      
    rs1 = get_register_bin(operands[0])
    rs2 = get_register_bin(operands[1])

    # if(int(imm) > 2**20-1 or int(imm) < -2**20):
    #     raise BadImmediate()

    # if(operands[1][0] == '-'):
    #     rs1 = get_register_bin(operands[1].split('(')[1].rstrip(')'))
    #     if(rs1.isdigit == False):
    #         raise BadRegister()
    # else:
    #     rs1 = get_register_bin(operands[1].split('(')[1].rstrip(')'))
    #     if(rs1.isdigit == False):
    #         raise BadRegister()

    # if(operands[1][0] == '-'):
    #     imm = dec_to_bin(operands[1].split('(')[0], size = 12)
    #     # if(operands[1][0:2] < -(2^11)):
    #     #     raise BadImmediate()
    # else:
    #     imm = dec_to_bin(operands[1].split('(')[0], size = 12)
        # if(operands[1][0] > 2^11-1):
        #     raise BadImmediate()

   # if(int(imm) > 2^11-1 or int(imm) < -(2^11)):
    #    raise BadImmediate()

    # if(is_int(operands[2])):
    #     if(int(operands[2]) < -(2**12) or int(operands[2]) > 2**11-1):
    #             raise BadImmediate("Immediate value outside of bounds")
        
    #     offset = int(operands[2])
    # else:
    #     if(is_register_name(operands[2])):
    #         raise BadImmediate()
    #     offset = label_to_offset(labels, operands[2], line_num)
    

    # imm = dec_to_bin(offset >> 1, 12)

    # imm = str(imm)

    firstBits = imm[0]
    secondBits = imm[2:8]
    thirdBits = imm[8:12]
    lastBits = imm[1]
    
    field_data = inst_to_fields[cmd]

    first_imm = firstBits + secondBits

    inst_field_list = [first_imm,
                       rs2,
                       rs1,
                       field_data.func3,
                       thirdBits + lastBits, 
                       field_data.opcode]

    return join_inst_fields_bin(inst_field_list)
        

def Assemble_U_Type(cmd, operands, line_num):
    """Takes an U Type instruction name and its operands 
        (as a list) and returns the appropriate binary string.

        Raises BadInstruction exception when the cmd is not a valid U-type.

        Raises BadOperands exception when the wrong number of operands is
        provided.

        Raises BadRegister exception if the operand in a register
        position is not a valid register name.

        Raises BadImmediate exception when the value provided will not fit in
        the immediate space for the instruction or if there is a register
        specifier in the immediate operand location.
    """

   
    if(not is_core_inst(cmd)):
        raise BadInstruction()
    
    if(len(operands) != 2):
        raise BadOperands()
    
    if(operands[0][0] == '-'):
        rd = get_register_bin(operands[0])
        # if(rs1.isdigit == False):
        #     raise BadRegister()
    else:
        rd = get_register_bin(operands[0])
        # if(rs1.isdigit == False):
        #     raise BadRegister()
        
    if(operands[1][0] == '-'):
        if(operands[1][1:].isdecimal()):
            if(int(operands[1]) < -524288 or int(operands[1]) > 524287):
                raise BadImmediate("Immediate value outside of bounds")
        else:
            raise BadImmediate()
    else:
        if(operands[1].isdecimal()):
            if(int(operands[1]) < -524288 or int(operands[1]) > 524287):
                raise BadImmediate("Immediate value outside of bounds")
        else:
            raise BadImmediate()
    
    imm = dec_to_bin(operands[1], size = 20)

    
    field_data = inst_to_fields[cmd]

    inst_field_list = [imm,
                       rd,
                       field_data.opcode]

    return join_inst_fields_bin(inst_field_list)
    


def Assemble_UJ_Type(cmd, operands, line_num, labels):
    """Takes an UJ Type instruction name and its operands 
        (as a list) and returns the appropriate binary string.

        This method assumes that if a number is passed in as 
        the third operand (`operands[2]`) it is the PC offset, 
        not the immediate. Therefore the offset will be 
        right-shifted before the immediate is generated. 
        Otherwise it is assumed to be a label defined in `labels`.

        Raises BadInstruction exception when the cmd is not a valid UJ-type.

        Raises BadOperands exception when the wrong number of operands is
        provided.

        Raises BadRegister exception if one of the operands in a register
        position is not a valid register name.

        Raises BadImmediate exception when the value provided will not fit in
        the immediate space for the instruction or if there is a register
        specifier in the immediate operand location.

        Raises BadLabel exception if the immediate operand provided is a label
        but it is not defined in the `labels` dictionary.
    """
        
    if(not is_core_inst(cmd)):
        raise BadInstruction()
    
    if(len(operands) != 2):
        raise BadOperands()
    
    if(operands[0][0] == '-'):
        rd = get_register_bin(operands[0])
        # if(rs1.isdigit == False):
        #     raise BadRegister()
    else:
        rd = get_register_bin(operands[0])
        # if(rs1.isdigit == False):
        #     raise BadRegister()
   
    if(is_int(operands[1])):
        if(int(operands[1]) < -2**20 or int(operands[1]) > 2**20-1):
                raise BadImmediate("Immediate value outside of bounds")
        
        offset = int(operands[1])
    else:
        if(is_register_name(operands[1])):
            raise BadImmediate()
        offset = label_to_offset(labels, operands[1], line_num)
    

    imm = dec_to_bin(offset >> 1, 20)

    first_bit = imm[0]          
    second_bits = imm[1:9]     
    third_bit = imm[9]         
    fourth_bits = imm[10:20]    

    total_imm = first_bit + fourth_bits + third_bit + second_bits
    
    field_data = inst_to_fields[cmd]

    inst_field_list = [total_imm,
                       rd,
                       field_data.opcode]

    return join_inst_fields_bin(inst_field_list)

##############
#
# Comments, Labels, and other sugar
#
##############

def remove_comments(line):
    """Takes a line of assembly and removes any text after a comment character (`;`).\
        Returns `None` if line is entirely a comment."""
    #removes comment lines or blank lines
    line = line.lstrip()
    if(line.startswith(";") or not line.rstrip()):
        return None
    sline = line.split(";")
    return sline[0]

def parse_labels(asm_list):
    """Takes in a list where each entry is either a label, an instruction, 
        or a label and an instruction. Assumes there are no comments in this code.
        Returns a tuple containing a new list of only instructions (the labels 
        having been removed), and a dictionary mapping labels to addresses
        in the instruction list."""
    

    instructions = []
    label_dict = {}
    address = 0x00400000 # Address index starts at 0 and increments per instruction
    
    for line in asm_list:
        # Split the line into potential label and instruction
        parts = line.split(":", maxsplit=1)
        
        if len(parts) == 2:
            # If there's a label, map it to the current address
            label = parts[0].strip()

            if( label in label_dict.keys()):
                raise BadLabel()
            
            label_dict[label] = address
            
            # Check if there's an instruction after the label
            instruction = parts[1].strip()
            if instruction:
                instructions.append(instruction)
                address += 0X4
        else:
            # No label, just an instruction
            instruction = parts[0].strip()
            instructions.append(instruction)
            address += 0X4
    
    return instructions, label_dict

def index_to_address(index):
    """Given a line number or index in a program returns the RISC-V address
      of the instruction, assuming the program starts at the beginning 
      of the text segment of memory."""

    pc = 0x00400000
    address = pc + index * 4
    return address

def label_to_offset(labels, label, instruction_index):
    """Takes in the dictionary of labels, a label of interest and a 
        current instruction-index (not an address). Returns the byte offset between 
        the label and PC calculated from the instruction index."""

    if(len(labels) == 0):
        pointer = 0x00400000

    elif(label not in labels):
        raise BadLabel()
    
    else:
        pointer = labels[label]
    
    # Calculate the instruction offset
    instruction_offset = index_to_address(instruction_index)
    
    # Convert instruction offset to byte offset (each instruction is 4 bytes)
  #  byte_offset = instruction_offset * 4
    
    return pointer - instruction_offset

def split_out_label(line):
    """Takes a line of raw assembly code and splits any label from the beginning
    of the line.  Returns a tuple of label and instruction, either of which
    could be None (if they don't exist).

    Will return (str, None) if there's a label alone on the line.
    Will return (None, str) if there's no label on the line.
    Will return (str, str) if there's both a label and code on the line.
    Or it might return (None, None) if there's no label or instruction.
    """

    clean = line.strip()
    
    # case 1: line is exclusively a label (and whitespace)
    # case 2: line has a label and maybe an instruction
    if ":" in clean:
        # this is a sneaky one-liner to do the same thing
        #[label, inst] = [x.strip() if len(x.strip()) > 0 else None for x in line.split(":",1)]
        [label, inst] = line.split(":", 1)
        label = label.strip()
        inst = inst.strip() if len(inst.strip()) > 0 else None
        if(len(label.split()) > 1): raise BadLabel("Whitespace chars disallowed in labels")
        return (label, inst)
    
    # case 3: no label, return only the code
    return (None, clean)


def has_label(line):
    """Takes a line of raw assembly code, and returns True if the line either
    *is* or contains a label."""
    (label, inst) = split_out_label(line)
    return label is not None


##############
#
# Output 
#
##############

def output(machine_code, clean_code, labels, mode = None, out = None):
    """Takes in two lists, the first a list of binary machine translations,
    the second a list containing the raw assembly associated with each 
    instruction (no comments or blank lines).

    These two lists must be the same size.

    Also takes in the labels dictionary to add labels to the output.

    If `out` is None then the output is printed to the console, otherwise
    the output is written to the file specified by the `out` parameter.

    If mode is `None` then outputs binary with hex and raw assembly in comments.

    If mode is `bin` then outputs binary with raw assembly in comments (no hex).

    If mode is `hex` outputs hex with raw assembly in comments (no binary).

    Addresses of each instruction are always printed in the comments.
    """
    i = int("00400000", 16)
    address_to_label = {v:k for (k,v) in labels.items()}
    for m, c in zip(machine_code, clean_code):
        label = "\t"
        if(i in address_to_label):
            label = address_to_label[i] + ":\t"
        if(not mode):
            s = ("%s // 0x%s ;;; %s - %s%s " % (m, bin_to_hex(m), hex(i), label, c.rstrip()))
        elif (mode == "bin"):
            s = ("%s // %s - %s%s " % (m, hex(i), label, c.rstrip()))
        else:
            s = ("%s // %s - %s%s " % (bin_to_hex(m), hex(i), label, c.rstrip()))

        if(out):
            out.write(s+"\n")
        else:
            print(s)
        i += 4

##############
#
# Utilities 
#
##############

#Enum of Types
Types = Enum("Types", ["R", "I", "S", "SB", "U", "UJ", "PSEUDO"])
"""Enum of instruction Types"""

#dictionary mapping instruction name to types
inst_to_types = {#R types
                "add":Types.R, "sub":Types.R, "xor":Types.R, "or":Types.R, "and":Types.R, "sll":Types.R,
                "srl":Types.R, "sra":Types.R, "slt":Types.R, 
                #I Types and S Types
                "addi":Types.I, "xori":Types.I, "ori":Types.I, "andi":Types.I, "slli":Types.I, "srli":Types.I,
                "srai":Types.I, "lw":Types.I, "sw":Types.S, "jalr":Types.I,
                #SB Types
                "beq":Types.SB, "bne":Types.SB, "blt":Types.SB, "bge":Types.SB, 
                #U and UJ Types
                "jal":Types.UJ, "lui":Types.U
                }
"""Dictionary mapping instruction name to types"""

class FieldData():
    """
    Struct to hold data for different fields of instructions.
    """
    def __init__(self, opcode, func3=None, func7=None):
        self.opcode = opcode
        self.func7 = func7
        self.func3 = func3
        

#dictionay mapping instruction name to the different fields as a FieldData object
inst_to_fields = {#R types
                "add":FieldData("0110011", "000", "0000000"), 
                "sub":FieldData("0110011", "000", "0100000"), 
                "xor":FieldData("0110011", "100", "0000000"), 
                "or": FieldData("0110011", "110", "0000000"), 
                "and":FieldData("0110011", "111", "0000000"), 
                "sll":FieldData("0110011", "001", "0000000"),
                "srl":FieldData("0110011", "101", "0000000"), 
                "sra":FieldData("0110011", "101", "0100000"), 
                "slt":FieldData("0110011", "010", "0000000"), 
                #I Types and S Types
                "addi":FieldData("0010011", "000"), 
                "xori":FieldData("0010011", "100"), 
                "ori": FieldData("0010011", "110"), 
                "andi":FieldData("0010011", "111"), 
                "slli":FieldData("0010011", "001"), 
                "srli":FieldData("0010011", "101"),
                "srai":FieldData("0010011", "101"), 
                "lw":  FieldData("0000011", "010"), 
                "sw":  FieldData("0100011", "010"), 
                "jalr":FieldData("1100111", "000"),
                #SB Types
                "beq":FieldData("1100011", "000"), 
                "bne":FieldData("1100011", "001"), 
                "blt":FieldData("1100011", "100"), 
                "bge":FieldData("1100011", "101"), 
                #U and UJ Types
                "jal":FieldData("1101111"), 
                "lui":FieldData("0110111")
                }
"""Dictionay mapping instruction name to the different fields as a FieldData object"""

#dictionary that maps register names to their ID numbers (in decimal)
register_name_to_num = {"x0":0, "zero":0, "x1":1, "ra":1,
                        "x2":2, "sp":2, "x3":3, "gp":3, 
                        "x4":4, "tp":4, "x5":5, "t0":5,
                        "x6":6, "t1":6, "x7":7, "t2":7,
                        "x8":8, "s0":8, "fp":8, 
                        "x9":9, "s1":9, "x10":10, "a0":10, 
                        "x11":11, "a1":11, "x12":12, "a2":12,
                        "x13":13, "a3":13, "x14":14, "a4":14,
                        "x15":15, "a5":15, "x16":16, "a6":16,
                        "x17":17, "a7":17, "x18":18, "s2":18,
                        "x19":19, "s3":19, "x20":20, "s4":20,
                        "x21":21, "s5":21, "x22":22, "s6":22,
                        "x23":23, "s7":23, "x24":24, "s8":24,
                        "x25":25, "s9":25, "x26":26, "s10":26,
                        "x27":26, "s11":27, "x28":28, "t3":28,
                        "x29":29, "t4":29, "x30":30, "t5":30,
                        "x31":31, "at":31
                        }
"""Dictionary that maps register names to their ID numbers (in decimal)"""

def is_register_name(name):
    """Returns True if the provided name is a valid register name or x value."""
    return name in register_name_to_num.keys()

def get_register_bin(name):
    """Returns the binary string version of a register ID given its name."""
    if(name not in register_name_to_num.keys()):
        raise BadRegister("Found unknown register name: \n\t%s\n" % name)
        
    binary_string = format(register_name_to_num[name], "#05b")[2:]
    return "0"*(5-len(binary_string)) + binary_string
    
def is_shift_immediate_inst(inst):
    """Returns true if this is a shift immediate instruction."""
    return inst in ["slli", "srli", "srai"]

def is_core_inst(inst):
    """Returns true if this instruction is in our list of core instructions."""
    return inst in inst_to_types.keys()

def parse_base_offset(operand_string):
    """Takes in the base-offset address field from memory instructions
        returns a tuple including the binary immediate and binary register.

        Assumes the immediate is in decimal.

        e.g. `lw t0, 4(t1)` will lead to this behavior:

            `parse_base_offset("4(t1)") -> ("000000000100", "00110")` """
    #remove the close paren
    operand_string = operand_string.replace(")", "")
    #split on the open to separate the parts
    pieces = operand_string.split("(")
    if(len(pieces) != 2):
        raise BadImmediate("Parsing base-offset address, inappropriate number of elements: \n\t%s\n" % operand_string)

    imm = dec_to_bin(pieces[0])
    rs1 = get_register_bin(pieces[1])
    return (imm, rs1)

def verify_field_sizes(inst_list, inst_type, line_num):
    """Takes in a list where each element is a binary string of one field 
        of an instruction `inst_type` is the Type of the instruction, and 
        `line_num` is the instruction index in the assembled program 
        (`line_num` is only used for error output).

        For example, you could call it this way:

            verify_field_sizes((funct7, rs2, rs1, funct3, rd, opcode), Types.R, 23) 
        
        And it would check that all the various funct7, etc values are an
        appropriate number of bits (well, actually characters since they're
        strings of ones and zeroes).
    """
    raise NotImplementedError

def reverse_string(s):
    """A helper function to reverse strings using list slicing. 
        Just syntactic sugar to help with readability."""
    return s[::-1] 

def is_int(s):
    """Checks if a given string can be an integer or not."""
    try:
        int(s)
    except ValueError:
        return False
    return True

###### Functions to convert between different bases #####

def dec_to_bin(decimal, size=12):
    """Takes a decimal numer (as int or string) and returns the 
        binary representation with number of bits equal to `size`. 
        Uses the two's compliment representation for negative numbers."""
    
    if(type(decimal) == str):
        try:
            decimal = int(decimal)
        except ValueError:
            raise BadImmediate("Failed to parse value as an integer: %s" % (decimal))
    
    if(decimal >= 2**size):
        raise BadImmediate("Not enough bits (%s) to represent the decimal number: %s" % (size, decimal))

    binary_string = bin(((1 << size) - 1) & decimal)
    binary_string = binary_string[2:]
    return "0"*(size-len(binary_string)) + binary_string

def join_inst_fields_bin(inst_list):
    """Takes a list of binary strings and joins them together 
        and grouping into 4 character slices."""
    binary_string = "".join(inst_list)
    binary_string = binary_string.replace(" ", "")
    binary_string = "0"*(32-len(binary_string)) + binary_string
    binary_string = " ".join(binary_string[i:i+4] for i in range(0, 32, 4))
    return binary_string

def bin_to_hex(bin_string):
    """Takes a binary string and converts it into a hex string."""
    #the [2:] here string off the leading '0x' of the hex string
    if(bin_string == None):
        return
    #remove any whitespace in the string
    bin_string = bin_string.replace(" ", "")
    result = hex(int(bin_string, 2))[2:]
    #add in any missing leading zeros
    return "0"*(8-len(result)) + result


##############
#
# Custom Exceptions for Debugging and Niceness 
#
##############

class BadImmediate(Exception):
    """Indicates an immediate is not the right size (in bits) for a given instruction, or some other formatting issue."""
    pass

class BadOperands(Exception):
    """Indicates that the number or type of operands passed to an instruction are incorrect."""
    pass

class BadInstruction(Exception):
    """Indicates that an unknown instruction has been found."""
    pass

class BadRegister(Exception):
    """Indicates that an unknown register has been found."""
    pass

class BadField(Exception):
    """Indicates that the number of bits for an instruction field is incorrect."""
    pass

class BadFormat(Exception):
    """Indicates that the number of fields for a given instruction does not match the format."""
    pass

class BadLabel(Exception):
    """Indicates that a problematic label has been found."""
    pass

##############
#
# Arguments etc.
#
##############
def parse_args():
    """Parses the arguments to the assembler and returns them as a 
        argparse.Namespace object.
        See the python docs for usage.
        """
    parser = argparse.ArgumentParser(description="A parser for 32-bit RISC-V assembly files.")
    parser.add_argument("asm", type=argparse.FileType('r'), help="An asm file containing RISC-V code. \
                        Whitespace will be ignored. Text after a ; is treated as comments. \
                        Labels are identified by a trailing :, they can be on their own line or share a \
                        line with an instruction.")
    parser.add_argument("--out", "-o", type=argparse.FileType('w'), help="The name of the output file that\
                         the assembled machine code will be written to.")
    parser.add_argument("--mode", "-m", choices=["bin","hex"], default="bin", help="The output mode for the\
                         machine file: binary or hexadecimal.")
    parser.add_argument("--verbose", "-v", action="store_true", help="If true then the final output will\
                         include comments listing the RISC-V command that was disassembled on each line, \
                        along with both binary and hex translations.")
    parser.add_argument("--pseudos", "-p", type=argparse.FileType('r'), help="An optional file that defines\
                         pseudoinstructions that this assembler should support.\
                        You should ignore and not use this option unless you talk to an instructor about it.\
                        Pseudoinstruction names and arguments should be listed with a trailing = on one line\
                        then the instructions that define this pseudoinstruction should follow using the argument\
                         names defined on the first line in place of register operands.\
                        EOF or a new pseudoinstruction definition will dileneate the new definitions. \
                        This assumes any register names or numbers (e.g. at, x31, or 31) are constant and should not be\
                         replaced, so dont use register names in the definition. An example:\n\
                        \t double r1, r2 =\
                        \t add r1, r2, r2")
    
    return parser.parse_args()


if __name__== "__main__":
    main(parse_args())






                                    </code></pre>
                                </div>
                            </div>


                        </div>
                    </div>
                </div>

                <div class="project">
                    <div class="project-header">
                        <div>
                            <p class="project-title">Genetic Algorithm Research (Project Leader)</p>
                            <p class="date">Aug 2023 – Nov 2023</p>
                        </div>
                        <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <p class="description">
                        • Led development of evolutionary simulator implementing genetic algorithms
                        • Designed and implemented chromosome visualization/editor with mutation, crossover, and
                        selection mechanisms
                        • Developed multiple fitness functions (bit counting, target matching, consecutive 1s) and
                        selection algorithms
                        • Created GUI-based evolution simulator with real-time population visualization and statistical
                        analysis
                        • Implemented truncation, roulette wheel, and ranked selection methods with comparative
                        performance analysis
                        • Conducted experiments demonstrating genetic algorithm behavior across different parameter
                        configurations
                        • Successfully reproduced results from <a
                            href="https://pages.ucsd.edu/~rbelew/courses/cogs184_w10/readings/HintonNowlan97.pdf"
                            target="_blank" rel="noopener noreferrer">"How Learning Can Guide Evolution"</a> scientific
                        paper
                        • Utilized object-oriented design principles with inheritance for selection methods and
                        interfaces for fitness functions
                        • <a href="https://github.com/rhit-csse220/csse220-fall-2024-2025-final-project-f24_r203"
                            target="_blank" rel="noopener noreferrer" class="more-info-link">View Project Details ↗</a>
                    </p>
                </div>
            </section>

            <section id="work-experience" aria-label="Work Experience">
                <h2>Work Experience</h2>
                <div class="job">
                    <div class="job-header">
                        <div>
                            <p class="job-title">Intern</p>
                            <p class="company">JRC Integrated Systems, Crane, IN</p>
                            <p class="date">May 2025 – Aug 2025</p>
                        </div>
                        <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <p class="description">
                        • Software work on radiation hardened electronics simulation and parallelization
                        • Semiconductors, Argonne linear solver addition, CUDA, server-side optimizations
                    </p>
                </div>
                <div class="job">
                    <div class="job-header">
                        <div>
                            <p class="job-title">Software Engineering Intern</p>
                            <p class="company">YolBe, Chicago, IL</p>
                            <p class="date">May 2024 - Aug 2024</p>
                        </div>
                        <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                    </div>
                    <p class="description">
                        • Tested and fixed bugs, coded SQL queries to analyze user activity
                        • Constructed dashboards and analytical reports using Redash and Mixpanel
                        • Engineered prompts for company AI
                        • Performed analysis on analytics and user engagement
                    </p>
                </div>
            </section>
            <section id="more-info-section" aria-label="More Info">
                <h2>More Info</h2>
                <p><strong>Education:</strong> Bachelor of Science, Computer Engineering, Rose-Hulman Institute of
                    Technology (Expected May 2027)</p>
                <p></p> GPA 3.48/4.0</p>
                <p>3x Dean's List </p>
                <p><strong>Relevant Courses:</strong>Programming Language Concepts, Embedded Systems, Operating Systems,
                    Computer
                    Architecture, AC Circuits, Digital Systems, Signal Processing, OOP, Data Structures & Algorithms,
                    Signals and Systems</p>
                <section id="campus-experience" aria-label="Campus Experience">
                    <h2>Campus Experience</h2>
                    <div class="campus-activity">
                        <div class="campus-header">
                            <div>
                                <p class="campus-title">USLI Rocketry Team (NASA Student Launch Initiative)</p>
                                <p class="date">Mar 2025 – Present</p>
                            </div>
                            <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </div>
                        <p class="description">
                            • Member of Rose-Hulman's NASA Student Launch Initiative team designing and building
                            high-power rockets
                            • Contribute to avionics and flight computer systems development
                            • Participate in system integration and pre-launch testing procedures
                            • Work on payload design meeting NASA mission requirements
                            • Prepare documentation and reports for NASA design reviews
                        </p>
                    </div>
                    <div class="campus-activity">
                        <div class="campus-header">
                            <div>
                                <p class="campus-title">Rose Competitive Programming Team</p>
                                <p class="date">Sept 2024 – Present</p>
                            </div>
                            <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </div>
                        <p class="description">
                            • Member of Rose-Hulman's competitive programming team competing in ICPC and other
                            programming contests
                            • Regularly practice algorithm problems and participate in team coding competitions
                            • Focus on developing efficient solutions to complex computational problems under time
                            constraints
                            • Collaborated with teammates to solve problems using data structures and advanced
                            algorithms
                        </p>
                    </div>

                    <div class="campus-activity">
                        <div class="campus-header">
                            <div>
                                <p class="campus-title">Battery Workforce Challenge</p>
                                <p class="date">Mar 2024 – Mar 2025</p>
                            </div>
                            <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </div>
                        <p class="description">
                            • Worked under the Battery Management System team for the Rose-Hulman Battery Workforce
                            Challenge team
                            • Developed controls and response systems for electric vehicle pre-charging and crash
                            detection using Simulink
                            • Implemented serial communication protocols with microcontrollers for battery monitoring
                            • Collaborated with mechanical and electrical engineering students on integrated system
                            design
                            • <a href="https://avtcseries.org/about-the-battery-workforce-challenge/" target="_blank"
                                rel="noopener noreferrer" class="more-info-link">More Info</a>
                        </p>
                    </div>

                    <div class="campus-activity">
                        <div class="campus-header">
                            <div>
                                <p class="campus-title">ESCALATE Student Entrepreneur Program</p>
                                <p class="date">Aug 2023 – Present</p>
                            </div>
                            <svg class="toggle-icon" width="16" height="16" viewBox="0 0 24 24" fill="none"
                                stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </div>
                        <p class="description">
                            • Participate in entrepreneurship program focused on technology commercialization
                            • Develop business plans and pitch ideas for innovative tech solutions
                            • Collaborate with students from diverse disciplines to create viable product concepts
                            • Attend workshops on intellectual property, market analysis, and venture funding
                            • Network with industry professionals and successful entrepreneurs
                        </p>
                    </div>


                </section>
            </section>


        </div>
    </main>

    <footer>
        &copy; 2025 John Tansey
    </footer>

    <script>
        const codeSections = document.querySelectorAll('.code-section');
        codeSections.forEach(section => {
            const header = section.querySelector('.code-header');
            const content = section.querySelector('.code-content');

            header.addEventListener('click', () => {
                section.classList.toggle('active');
                if (section.classList.contains('active')) {
                    content.style.maxHeight = content.scrollHeight + 'px';
                } else {
                    content.style.maxHeight = '0';
                }
            });
        });
        function toggleCodeDropdown(dropdownId) {
            const dropdown = document.getElementById(dropdownId).parentElement;
            dropdown.classList.toggle('active');

            document.querySelectorAll('.code-dropdown').forEach(dd => {
                if (dd !== dropdown) {
                    dd.classList.remove('active');
                }
            });
        }
        document.addEventListener('click', function (event) {
            if (!event.target.closest('.code-dropdown')) {
                document.querySelectorAll('.code-dropdown').forEach(dd => {
                    dd.classList.remove('active');
                });
            }
        });

        fetch('./assembler.py')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Could not load assembler.py');
                }
                return response.text();
            })
            .then(code => {
                document.getElementById('assembler-code').textContent = code;
            })
            .catch(error => {
                document.getElementById('assembler-code').textContent = 'Error loading code: ' + error.message;
            });
        document.addEventListener('DOMContentLoaded', function () {
            const campusActivities = document.querySelectorAll('.campus-activity');
            campusActivities.forEach(activity => {
                const header = activity.querySelector('.campus-header');
                const description = activity.querySelector('.description');

                header.addEventListener('click', () => {
                    activity.classList.toggle('active');
                    if (activity.classList.contains('active')) {
                        description.style.maxHeight = description.scrollHeight + 'px';
                    } else {
                        description.style.maxHeight = '0';
                    }
                });
            });
            const projects = document.querySelectorAll('.project');
            projects.forEach(project => {
                const header = project.querySelector('.project-header');
                const description = project.querySelector('.description');

                header.addEventListener('click', () => {
                    project.classList.toggle('active');
                    if (project.classList.contains('active')) {
                        description.style.maxHeight = description.scrollHeight + 'px';
                    } else {
                        description.style.maxHeight = '0';
                    }
                });
            });

            const jobs = document.querySelectorAll('.job');
            jobs.forEach(job => {
                const header = job.querySelector('.job-header');
                const description = job.querySelector('.description');

                header.addEventListener('click', () => {
                    job.classList.toggle('active');
                    if (job.classList.contains('active')) {
                        description.style.maxHeight = description.scrollHeight + 'px';
                    } else {
                        description.style.maxHeight = '0';
                    }
                });
            });
        });
    </script>

</body>

</html>